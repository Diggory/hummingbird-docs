{"sections":[],"metadata":{"role":"collectionGroup","title":"Router","modules":[{"name":"Hummingbird"}]},"abstract":[{"type":"text","text":"The router directs requests to their handlers based on the contents of their path."}],"primaryContentSections":[{"kind":"content","content":[{"level":2,"type":"heading","anchor":"Overview","text":"Overview"},{"type":"paragraph","inlineContent":[{"text":"The default router that comes with Hummingbird uses a Trie based lookup. Routes are added using the function ","type":"text"},{"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/Router\/on(_:method:use:)-3copy","type":"reference","isActive":true},{"text":". You provide the URI path, the method and the handler function. Below is a simple route which returns “Hello” in the body of the response.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let router = Router()","router.on(\"\/hello\", method: .GET) { request, context in","    return \"Hello\"","}"]},{"type":"paragraph","inlineContent":[{"text":"If you don’t provide a path then the default is for it to be “\/”.","type":"text"}]},{"level":3,"type":"heading","anchor":"Methods","text":"Methods"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are shortcut functions for the most common HTTP methods. The above can be written as"}]},{"type":"codeListing","syntax":"swift","code":["let router = Router()","app.router.get(\"\/hello\") { request, context in","    return \"Hello\"","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are shortcuts for "},{"type":"codeVoice","code":"put"},{"type":"text","text":", "},{"type":"codeVoice","code":"post"},{"type":"text","text":", "},{"type":"codeVoice","code":"head"},{"type":"text","text":", "},{"type":"codeVoice","code":"patch"},{"type":"text","text":" and "},{"type":"codeVoice","code":"delete"},{"type":"text","text":" as well."}]},{"level":3,"type":"heading","anchor":"Response-generators","text":"Response generators"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Route handlers are required to return a type conforming to the "},{"code":"ResponseGenerator","type":"codeVoice"},{"type":"text","text":" protocol. The "},{"code":"ResponseGenerator","type":"codeVoice"},{"type":"text","text":" protocol requires a type to be able to generate an "},{"code":"Response","type":"codeVoice"},{"type":"text","text":". For example "},{"code":"String","type":"codeVoice"},{"type":"text","text":" has been extended to conform to "},{"code":"ResponseGenerator","type":"codeVoice"},{"type":"text","text":" by returning an "},{"code":"Response","type":"codeVoice"},{"type":"text","text":" with status "},{"code":".ok","type":"codeVoice"},{"type":"text","text":",  a content-type header of "},{"code":"text-plain","type":"codeVoice"},{"type":"text","text":" and a body holding the contents of the "},{"code":"String","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["\/\/\/ Extend String to conform to ResponseGenerator","extension String: ResponseGenerator {","    \/\/\/ Generate response holding string","    public func response(from request: Request, context: some BaseRequestContext) -> Response {","        let buffer = context.allocator.buffer(string: self)","        return Response(status: .ok, headers: [\"content-type\": \"text\/plain; charset=utf-8\"], body: .byteBuffer(buffer))","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In addition to "},{"code":"String","type":"codeVoice"},{"type":"text","text":" "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":", "},{"code":"HTTPResponseStatus","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Optional","type":"codeVoice"},{"type":"text","text":" have also been extended to conform to "},{"code":"ResponseGenerator","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It is also possible to extend "},{"code":"Codable","type":"codeVoice"},{"type":"text","text":" objects to generate "},{"code":"Response","type":"codeVoice"},{"type":"text","text":" by conforming these objects to "},{"code":"ResponseEncodable","type":"codeVoice"},{"type":"text","text":". The object will use the response encoder attached to your context to encode these objects. If an object conforms to "},{"code":"ResponseEncodable","type":"codeVoice"},{"type":"text","text":" then also so do arrays and dictionaries of these objects."}]},{"level":3,"type":"heading","anchor":"Wildcards","text":"Wildcards"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use wildcards to match sections of a path component."}]},{"type":"paragraph","inlineContent":[{"text":"A single ","type":"text"},{"code":"*","type":"codeVoice"},{"text":" will skip one path component","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["app.router.get(\"\/files\/*\") { request, context in","    return request.uri.description","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Will match"}]},{"type":"codeListing","syntax":null,"code":["GET \/files\/test","GET \/files\/test2"]},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"type":"codeVoice","code":"*"},{"text":" at the start of a route component will match all path components with the same suffix.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["app.router.get(\"\/files\/*.jpg\") { request, context in","    return request.uri.description","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Will work for"}]},{"type":"codeListing","syntax":null,"code":["GET \/files\/test.jpg","GET \/files\/test2.jpg"]},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"code":"*","type":"codeVoice"},{"text":" at the end of a route component will match all path components with the same prefix.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["app.router.get(\"\/files\/image.*\") { request, context in","    return request.uri.description","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Will work for"}]},{"type":"codeListing","syntax":null,"code":["GET \/files\/image.jpg","GET \/files\/image.png"]},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"code":"**","type":"codeVoice"},{"text":" will match and capture all remaining path components.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["app.router.get(\"\/files\/**\") { request, context in","    \/\/ return catchAll captured string","    return context.parameters.getCatchAll().joined(separator: \"\/\")","}"]},{"type":"paragraph","inlineContent":[{"text":"The above will match routes and respond as follows","type":"text"}]},{"type":"codeListing","syntax":null,"code":["GET \/files\/image.jpg returns \"image.jpg\" in the response body","GET \/files\/folder\/image.png returns \"folder\/image.png\" in the response body"]},{"level":3,"type":"heading","anchor":"Parameter-Capture","text":"Parameter Capture"},{"type":"paragraph","inlineContent":[{"text":"You can extract parameters out of the URI by prefixing the path with a colon. This indicates that this path section is a parameter. The parameter name is the string following the colon. You can get access to the URI extracted parameters from the context. This example extracts an id from the URI and uses it to return a specific user. so “\/user\/56” will return user with id 56.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["app.router.get(\"\/user\/:id\") { request, context in","    let id = context.parameters.get(\"id\", as: Int.self) else { throw HTTPError(.badRequest) }","    return getUser(id: id)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above if I fail to access the parameter as an "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" then I throw an error. If you throw an "},{"type":"reference","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdCore\/HTTPError","isActive":true},{"type":"text","text":" it will get converted to a valid HTTP response."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The parameter name in your route can also be of the form "},{"type":"codeVoice","code":"{id}"},{"type":"text","text":", similar to OpenAPI specifications. With this form you can also extract parameter values from the URI that are prefixes or suffixes of a path component."}]},{"type":"codeListing","syntax":"swift","code":["app.router.get(\"\/files\/{image}.jpg\") { request, context in","    let imageName = context.parameters.get(\"image\") else { throw HTTPError(.badRequest) }","    return getImage(image: imageName)","}"]},{"type":"paragraph","inlineContent":[{"text":"In the example above we match all paths that are a file with a jpg extension inside the files folder and then call a function with that image name.","type":"text"}]},{"level":3,"type":"heading","anchor":"Groups","text":"Groups"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Routes can be grouped together in a "},{"type":"codeVoice","code":"RouterGroup"},{"type":"text","text":".  These allow for you to prefix a series of routes with the same path and more importantly apply middleware to only those routes. The example below is a group that includes five handlers all prefixed with the path “\/todos”."}]},{"type":"codeListing","syntax":"swift","code":["let app = Application()","app.router.group(\"\/todos\")","    .put(use: createTodo)","    .get(use: listTodos)","    .get(\"{id}\", getTodo)","    .patch(\"{id}\", editTodo)","    .delete(\"{id}\", deleteTodo)"]},{"level":3,"type":"heading","anchor":"Route-handlers","text":"Route handlers"},{"type":"paragraph","inlineContent":[{"text":"A route handler ","type":"text"},{"type":"codeVoice","code":"RouteHandler"},{"text":" allows you to encapsulate all the components required for a route, and provide separation of the extraction of input parameters from the request and the processing of those parameters. An example could be structrured as follows","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct AddOrder: RouteHandler {","    struct Input: Decodable {","        let name: String","        let amount: Double","    }","    struct Output: ResponseEncodable {","        let id: String","    }","    let input: Input","    let user: User","    ","    init(from request: Request, context: some AuthRequestContext) async throws {","        self.input = try await request.decode(as: Input.self, context: context)","        self.user = try context.auth.require(User.self)","    }","    func handle(context: some AuthRequestContext) async throws -> Output {","        let order = Order(user: self.user.id, details: self.input)","        let order = try await order.save(on: db)","        return Output(id: order.id)","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"Here you can see the ","type":"text"},{"type":"codeVoice","code":"AddOrder"},{"text":" route handler encapsulates everything you need to know about the add order route. The ","type":"text"},{"type":"codeVoice","code":"Input"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Output"},{"text":" structs are defined and any additional input parameters that need extracted from the ","type":"text"},{"type":"codeVoice","code":"Request"},{"text":". The input parameters are extracted in the ","type":"text"},{"type":"codeVoice","code":"init"},{"text":" and then the those parameters are processed in the ","type":"text"},{"type":"codeVoice","code":"handle"},{"text":" function. In this example we need to decode the ","type":"text"},{"type":"codeVoice","code":"Input"},{"text":" from the ","type":"text"},{"type":"codeVoice","code":"Request"},{"text":" and using the authentication framework from ","type":"text"},{"type":"codeVoice","code":"HummingbirdAuth"},{"text":" we get the authenticated user.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The following will add the handler to the application","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["application.router.put(\"order\", use: AddOrder.self)"]},{"level":3,"type":"heading","anchor":"Request-body","text":"Request body"},{"type":"paragraph","inlineContent":[{"type":"text","text":"By default the request body is an AsyncSequence of ByteBuffers. You can treat it as a series of buffers or collect it into one larger buffer."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ process each buffer in the sequence separately","for try await buffer in request.body {","    process(buffer)","}"]},{"type":"codeListing","syntax":"swift","code":["\/\/ collect all the buffers in the sequence into a single buffer","let buffer = try await request.body.collate(maxSize: maximumBufferSizeAllowed)","}"]},{"type":"paragraph","inlineContent":[{"text":"Once you have read the sequence of buffers you cannot read it again. If you want to read the contents of a request body in middleware before it reaches the route handler, but still have it available for the route handler you can use ","type":"text"},{"code":"Request.collateBody(context:)","type":"codeVoice"},{"text":". After this point though the request body cannot be treated as a sequence of buffers as it has already been collapsed into a single buffer.","type":"text"}]},{"level":3,"type":"heading","anchor":"Editing-response-in-handler","text":"Editing response in handler"},{"type":"paragraph","inlineContent":[{"text":"The standard way to provide a custom response from a route handler is to return a ","type":"text"},{"code":"Response","type":"codeVoice"},{"text":" from that handler. This method loses a lot of the automation of encoding responses, generating the correct status code etc.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Instead you can return what is called a ","type":"text"},{"code":"EditedResponse","type":"codeVoice"},{"text":". This includes a type that can generate a response on its own via the ","type":"text"},{"code":"ResponseGenerator","type":"codeVoice"},{"text":" protocol and includes additional edits to the response.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["application.router.post(\"test\") { request -> EditedResponse in","    return .init(","        status: .accepted,","        headers: [.contentType: \"application\/json\"],","        response: #\"{\"test\": \"value\"}\"#","    )","}"]}]}],"seeAlsoSections":[{"identifiers":["doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/MigratingToV2","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RequestContexts","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/EncodingAndDecoding","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/ErrorHandling","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/LoggingMetricsAndTracing","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/PersistentData","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/ServiceLifecycle","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/Testing"],"generated":true,"title":"Guides"}],"hierarchy":{"paths":[["doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird"]]},"kind":"article","topicSections":[{"identifiers":["doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/Router","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RouterGroup","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RouterMethods"],"title":"Reference"}],"identifier":{"url":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RouterGuide","interfaceLanguage":"swift"},"schemaVersion":{"major":0,"minor":3,"patch":0},"references":{"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/Router":{"role":"symbol","type":"topic","url":"\/documentation\/hummingbird\/router","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/Router","kind":"symbol","title":"Router","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Router","kind":"identifier"}],"abstract":[{"text":"Create rules for routing requests and then create ","type":"text"},{"code":"Responder","type":"codeVoice"},{"text":" that will follow these rules.","type":"text"}],"navigatorTitle":[{"text":"Router","kind":"identifier"}]},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/ServiceLifecycle":{"abstract":[{"text":"Integration with Swift Service Lifecycle","type":"text"}],"title":"Service Lifecycle","url":"\/documentation\/hummingbird\/servicelifecycle","role":"article","kind":"article","type":"topic","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/ServiceLifecycle"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/RouterMethods":{"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RouterMethods","type":"topic","role":"symbol","title":"RouterMethods","navigatorTitle":[{"text":"RouterMethods","kind":"identifier"}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"RouterMethods","kind":"identifier"}],"kind":"symbol","abstract":[{"type":"text","text":"Conform to "},{"type":"codeVoice","code":"RouterMethods"},{"type":"text","text":" to add standard router verb (get, post …) methods"}],"url":"\/documentation\/hummingbird\/routermethods"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/PersistentData":{"abstract":[{"type":"text","text":"How to persist data between requests to your server."}],"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/PersistentData","role":"collectionGroup","url":"\/documentation\/hummingbird\/persistentdata","type":"topic","kind":"article","title":"Persistent data"},"doc://com.opticalaberration.hummingbird/documentation/HummingbirdCore/HTTPError":{"title":"HTTPError","abstract":[{"type":"text","text":"Default HTTP error. Provides an HTTP status and a message"}],"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdCore\/HTTPError","role":"symbol","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"HTTPError"}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"HTTPError"}],"url":"\/documentation\/hummingbirdcore\/httperror"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/LoggingMetricsAndTracing":{"url":"\/documentation\/hummingbird\/loggingmetricsandtracing","title":"Logging, Metrics and Tracing","abstract":[{"type":"text","text":"Considered the three pillars of observability, logging, metrics and tracing provide different ways of viewing how your application is working."}],"type":"topic","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/LoggingMetricsAndTracing","kind":"article","role":"collectionGroup"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/RouterGroup":{"url":"\/documentation\/hummingbird\/routergroup","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RouterGroup","type":"topic","kind":"symbol","title":"RouterGroup","role":"symbol","abstract":[{"type":"text","text":"Used to group together routes under a single path. Additional middleware can be added to the endpoint and each route can add a"},{"type":"text","text":" "},{"type":"text","text":"suffix to the endpoint path"}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"RouterGroup"}],"navigatorTitle":[{"kind":"identifier","text":"RouterGroup"}]},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/ErrorHandling":{"role":"collectionGroup","type":"topic","url":"\/documentation\/hummingbird\/errorhandling","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/ErrorHandling","kind":"article","title":"Error Handling","abstract":[{"type":"text","text":"How to build errors for the server to return."}]},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/EncodingAndDecoding":{"abstract":[{"type":"text","text":"Hummingbird uses "},{"type":"codeVoice","code":"Codable"},{"text":" to decode requests and encode responses.","type":"text"}],"title":"Encoding and Decoding","url":"\/documentation\/hummingbird\/encodinganddecoding","role":"collectionGroup","kind":"article","type":"topic","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/EncodingAndDecoding"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/Router/on(_:method:use:)-3copy":{"fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"on","kind":"identifier"},{"text":"(","kind":"text"},{"text":"String","preciseIdentifier":"s:SS","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"method","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"HTTPRequest","preciseIdentifier":"s:9HTTPTypes11HTTPRequestV","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"Method","preciseIdentifier":"s:9HTTPTypes11HTTPRequestV6MethodV","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"use","kind":"externalParam"},{"text":": (","kind":"text"},{"text":"Request","preciseIdentifier":"s:15HummingbirdCore7RequestV","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"Context","preciseIdentifier":"s:11Hummingbird6RouterC7Contextxmfp","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"text":"async","kind":"keyword"},{"text":" ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"some","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ResponseGenerator","preciseIdentifier":"s:11Hummingbird17ResponseGeneratorP","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"Self","kind":"typeIdentifier"}],"role":"symbol","title":"on(_:method:use:)","url":"\/documentation\/hummingbird\/router\/on(_:method:use:)-3copy","abstract":[{"text":"Add path for closure returning type conforming to ResponseGenerator","type":"text"}],"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/Router\/on(_:method:use:)-3copy","type":"topic","kind":"symbol"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/MigratingToV2":{"abstract":[{"text":"Migration guide for converting Hummingbird v1 applications to Hummingbird v2","type":"text"}],"title":"Migrating to Hummingbird v2","url":"\/documentation\/hummingbird\/migratingtov2","role":"article","kind":"article","type":"topic","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/MigratingToV2"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/RequestContexts":{"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RequestContexts","kind":"article","title":"Request Contexts","type":"topic","abstract":[{"type":"text","text":"Controlling contextual data provided to middleware and route handlers"}],"role":"collectionGroup","url":"\/documentation\/hummingbird\/requestcontexts"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/Testing":{"abstract":[{"type":"text","text":"Using the HummingbirdTesting framework to test your application"}],"title":"Testing","url":"\/documentation\/hummingbird\/testing","role":"article","kind":"article","type":"topic","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/Testing"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird":{"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird","type":"topic","role":"collection","title":"Hummingbird","kind":"symbol","abstract":[{"type":"text","text":"Lightweight, modern, flexible server framework written in Swift."}],"url":"\/documentation\/hummingbird"}}}