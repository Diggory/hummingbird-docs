{"metadata":{"role":"collectionGroup","modules":[{"name":"Hummingbird"}],"title":"Router"},"hierarchy":{"paths":[["doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird"],["doc:\/\/com.opticalaberration.hummingbird\/documentation\/index"]]},"schemaVersion":{"patch":0,"minor":3,"major":0},"sections":[],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/Router"},"abstract":[{"type":"text","text":"The router directs requests to their handlers based on the contents of their path."}],"topicSections":[{"identifiers":["doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/HBRouter","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/HBRouterGroup","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/HBRouterMethods"],"title":"Reference"}],"seeAlsoSections":[{"identifiers":["doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/MigratingToV2","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RequestContexts","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/EncodingAndDecoding","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/ErrorHandling","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/LoggingMetricsAndTracing","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/PersistentData","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/ServiceLifecycle","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/Testing"],"generated":true,"title":"Guides"}],"primaryContentSections":[{"kind":"content","content":[{"text":"Overview","level":2,"anchor":"Overview","type":"heading"},{"inlineContent":[{"text":"The default router that comes with Hummingbird uses a Trie based lookup. Routes are added using the function ","type":"text"},{"isActive":true,"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/HBRouter\/on(_:method:options:use:)-1zuke","type":"reference"},{"text":". You provide the URI path, the method and the handler function. Below is a simple route which returns “Hello” in the body of the response.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let router = HBRouter()","router.on(\"\/hello\", method: .GET) { request, context in","    return \"Hello\"","}"],"type":"codeListing"},{"inlineContent":[{"text":"If you don’t provide a path then the default is for it to be “\/”.","type":"text"}],"type":"paragraph"},{"text":"Methods","anchor":"Methods","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"There are shortcut functions for the most common HTTP methods. The above can be written as"}],"type":"paragraph"},{"syntax":"swift","code":["let router = HBRouter()","app.router.get(\"\/hello\") { request, context in","    return \"Hello\"","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"There are shortcuts for "},{"type":"codeVoice","code":"put"},{"type":"text","text":", "},{"type":"codeVoice","code":"post"},{"type":"text","text":", "},{"type":"codeVoice","code":"head"},{"type":"text","text":", "},{"type":"codeVoice","code":"patch"},{"type":"text","text":" and "},{"type":"codeVoice","code":"delete"},{"type":"text","text":" as well."}],"type":"paragraph"},{"text":"Response generators","anchor":"Response-generators","type":"heading","level":3},{"inlineContent":[{"text":"Route handlers are required to return a type conforming to the ","type":"text"},{"type":"codeVoice","code":"HBResponseGenerator"},{"text":" protocol. The ","type":"text"},{"type":"codeVoice","code":"HBResponseGenerator"},{"text":" protocol requires a type to be able to generate an ","type":"text"},{"type":"codeVoice","code":"HBResponse"},{"text":". For example ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" has been extended to conform to ","type":"text"},{"type":"codeVoice","code":"HBResponseGenerator"},{"text":" by returning an ","type":"text"},{"type":"codeVoice","code":"HBResponse"},{"text":" with status ","type":"text"},{"type":"codeVoice","code":".ok"},{"text":",  a content-type header of ","type":"text"},{"type":"codeVoice","code":"text-plain"},{"text":" and a body holding the contents of the ","type":"text"},{"type":"codeVoice","code":"String"},{"text":".","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["\/\/\/ Extend String to conform to ResponseGenerator","extension String: HBResponseGenerator {","    \/\/\/ Generate response holding string","    public func response(from request: HBRequest, context: some HBBaseRequestContext) -> HBResponse {","        let buffer = context.allocator.buffer(string: self)","        return HBResponse(status: .ok, headers: [\"content-type\": \"text\/plain; charset=utf-8\"], body: .byteBuffer(buffer))","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"In addition to ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":", ","type":"text"},{"code":"HTTPResponseStatus","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Optional","type":"codeVoice"},{"text":" have also been extended to conform to ","type":"text"},{"code":"HBResponseGenerator","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"It is also possible to extend "},{"type":"codeVoice","code":"Codable"},{"type":"text","text":" objects to generate "},{"type":"codeVoice","code":"HBResponse"},{"type":"text","text":" by conforming these objects to "},{"type":"codeVoice","code":"HBResponseEncodable"},{"type":"text","text":". The object will use the response encoder attached to your context to encode these objects. If an object conforms to "},{"type":"codeVoice","code":"HBResponseEncodable"},{"type":"text","text":" then also so do arrays and dictionaries of these objects."}],"type":"paragraph"},{"text":"Wildcards","anchor":"Wildcards","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"You can use wildcards to match sections of a path component."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"A single "},{"type":"codeVoice","code":"*"},{"type":"text","text":" will skip one path component"}],"type":"paragraph"},{"syntax":"swift","code":["app.router.get(\"\/files\/*\") { request, context in","    return request.uri.description","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Will match"}],"type":"paragraph"},{"syntax":null,"code":["GET \/files\/test","GET \/files\/test2"],"type":"codeListing"},{"inlineContent":[{"text":"A ","type":"text"},{"code":"*","type":"codeVoice"},{"text":" at the start of a route component will match all path components with the same suffix.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["app.router.get(\"\/files\/*.jpg\") { request, context in","    return request.uri.description","}"],"type":"codeListing"},{"inlineContent":[{"text":"Will work for","type":"text"}],"type":"paragraph"},{"syntax":null,"code":["GET \/files\/test.jpg","GET \/files\/test2.jpg"],"type":"codeListing"},{"inlineContent":[{"text":"A ","type":"text"},{"type":"codeVoice","code":"*"},{"text":" at the end of a route component will match all path components with the same prefix.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["app.router.get(\"\/files\/image.*\") { request, context in","    return request.uri.description","}"],"type":"codeListing"},{"inlineContent":[{"text":"Will work for","type":"text"}],"type":"paragraph"},{"syntax":null,"code":["GET \/files\/image.jpg","GET \/files\/image.png"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"A "},{"code":"**","type":"codeVoice"},{"type":"text","text":" will match and capture all remaining path components."}],"type":"paragraph"},{"syntax":"swift","code":["app.router.get(\"\/files\/**\") { request, context in","    \/\/ return catchAll captured string","    return context.parameters.getCatchAll().joined(separator: \"\/\")","}"],"type":"codeListing"},{"inlineContent":[{"text":"The above will match routes and respond as follows","type":"text"}],"type":"paragraph"},{"syntax":null,"code":["GET \/files\/image.jpg returns \"image.jpg\" in the response body","GET \/files\/folder\/image.png returns \"folder\/image.png\" in the response body"],"type":"codeListing"},{"text":"Parameter Capture","anchor":"Parameter-Capture","type":"heading","level":3},{"inlineContent":[{"text":"You can extract parameters out of the URI by prefixing the path with a colon. This indicates that this path section is a parameter. The parameter name is the string following the colon. You can get access to the parameters extracted from the URI with ","type":"text"},{"type":"codeVoice","code":"HBRequest.parameters"},{"text":". If there are no URI parameters in the path, accessing ","type":"text"},{"type":"codeVoice","code":"HBRequest.parameters"},{"text":" will cause a crash, so don’t use it if you haven’t specified a parameter in the route path. This example extracts an id from the URI and uses it to return a specific user. so “\/user\/56” will return user with id 56.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["app.router.get(\"\/user\/:id\") { request in","    let id = request.parameters.get(\"id\", as: Int.self) else { throw HBHTTPError(.badRequest) }","    return getUser(id: id)","}"],"type":"codeListing"},{"inlineContent":[{"text":"In the example above if I fail to access the parameter as an ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" then I throw an error. If you throw an ","type":"text"},{"code":"HBHTTPError","type":"codeVoice"},{"text":" it will get converted to a valid HTTP response.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The parameter name in your route can also be of the form ","type":"text"},{"code":"{id}","type":"codeVoice"},{"text":", similar to OpenAPI specifications. With this form you can also extract parameter values from the URI that are prefixes or suffixes of a path component.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["app.router.get(\"\/files\/{image}.jpg\") { request in","    let imageName = request.parameters.get(\"image\") else { throw HBHTTPError(.badRequest) }","    return getImage(image: imageName)","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"In the example above we match all paths that are a file with a jpg extension inside the files folder and then call a function with that image name."}],"type":"paragraph"},{"text":"Groups","anchor":"Groups","type":"heading","level":3},{"inlineContent":[{"text":"Routes can be grouped together in a ","type":"text"},{"type":"codeVoice","code":"HBRouterGroup"},{"text":".  These allow for you to prefix a series of routes with the same path and more importantly apply middleware to only those routes. The example below is a group that includes five handlers all prefixed with the path “\/todos”.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let app = HBApplication()","app.router.group(\"\/todos\")","    .put(use: createTodo)","    .get(use: listTodos)","    .get(\"{id}\", getTodo)","    .patch(\"{id}\", editTodo)","    .delete(\"{id}\", deleteTodo)"],"type":"codeListing"},{"text":"Route handlers","anchor":"Route-handlers","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"A route handler "},{"type":"codeVoice","code":"HBRouteHandler"},{"type":"text","text":" allows you to encapsulate all the components required for a route, and provide separation of the extraction of input parameters from the request and the processing of those parameters. An example could be structrured as follows"}],"type":"paragraph"},{"syntax":"swift","code":["struct AddOrder: HBRouteHandler {","    struct Input: Decodable {","        let name: String","        let amount: Double","    }","    struct Output: HBResponseEncodable {","        let id: String","    }","    let input: Input","    let user: User","    ","    init(from request: HBRequest, context: some HBAuthRequestContextProtocol) async throws {","        self.input = try await request.decode(as: Input.self, context: context)","        self.user = try context.auth.require(User.self)","    }","    func handle(context: some HBAuthRequestContextProtocol) async throws -> Output {","        let order = Order(user: self.user.id, details: self.input)","        let order = try await order.save(on: db)","        return Output(id: order.id)","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Here you can see the "},{"type":"codeVoice","code":"AddOrder"},{"type":"text","text":" route handler encapsulates everything you need to know about the add order route. The "},{"type":"codeVoice","code":"Input"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Output"},{"type":"text","text":" structs are defined and any additional input parameters that need extracted from the "},{"type":"codeVoice","code":"HBRequest"},{"type":"text","text":". The input parameters are extracted in the "},{"type":"codeVoice","code":"init"},{"type":"text","text":" and then the those parameters are processed in the "},{"type":"codeVoice","code":"handle"},{"type":"text","text":" function. In this example we need to decode the "},{"type":"codeVoice","code":"Input"},{"type":"text","text":" from the "},{"type":"codeVoice","code":"HBRequest"},{"type":"text","text":" and using the authentication framework from "},{"type":"codeVoice","code":"HummingbirdAuth"},{"type":"text","text":" we get the authenticated user."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The following will add the handler to the application"}],"type":"paragraph"},{"syntax":"swift","code":["application.router.put(\"order\", use: AddOrder.self)"],"type":"codeListing"},{"text":"Request body","anchor":"Request-body","type":"heading","level":3},{"inlineContent":[{"text":"By default the request body is an AsyncSequence of ByteBuffers. You can treat it as a series of buffers or collect it into one larger buffer.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ process each buffer in the sequence separately","for try await buffer in request.body {","    process(buffer)","}"],"type":"codeListing"},{"syntax":"swift","code":["\/\/ collect all the buffers in the sequence into a single buffer","let buffer = try await request.body.collate(maxSize: maximumBufferSizeAllowed)","}"],"type":"codeListing"},{"inlineContent":[{"text":"Once you have read the sequence of buffers you cannot read it again. If you want to read the contents of a request body in middleware before it reaches the route handler, but still have it available for the route handler you can use ","type":"text"},{"type":"codeVoice","code":"HBRequest.collateBody(context:)"},{"text":". After this point though the request body cannot be treated as a sequence of buffers as it has already been collapsed into a single buffer.","type":"text"}],"type":"paragraph"},{"text":"Editing response in handler","anchor":"Editing-response-in-handler","type":"heading","level":3},{"inlineContent":[{"text":"The standard way to provide a custom response from a route handler is to return a ","type":"text"},{"code":"HBResponse","type":"codeVoice"},{"text":" from that handler. This method loses a lot of the automation of encoding responses, generating the correct status code etc.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Instead you can return what is called a ","type":"text"},{"code":"HBEditedResponse","type":"codeVoice"},{"text":". This includes a type that can generate a response on its own via the ","type":"text"},{"code":"HBResponseGenerator","type":"codeVoice"},{"text":" protocol and includes additional edits to the response.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["application.router.post(\"test\") { request -> HBEditedResponse in","    return .init(","        status: .accepted,","        headers: [.contentType: \"application\/json\"],","        response: #\"{\"test\": \"value\"}\"#","    )","}"],"type":"codeListing"}]}],"kind":"article","references":{"doc://com.opticalaberration.hummingbird/documentation/Hummingbird":{"title":"Hummingbird","url":"\/documentation\/hummingbird","kind":"symbol","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird","type":"topic","abstract":[{"text":"Lightweight, modern, flexible server framework written in Swift.","type":"text"}],"role":"collection"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/HBRouterMethods":{"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HBRouterMethods","kind":"identifier"}],"kind":"symbol","navigatorTitle":[{"text":"HBRouterMethods","kind":"identifier"}],"role":"symbol","abstract":[{"type":"text","text":"Conform to "},{"code":"HBRouterMethods","type":"codeVoice"},{"type":"text","text":" to add standard router verb (get, post …) methods"}],"title":"HBRouterMethods","url":"\/documentation\/hummingbird\/hbroutermethods","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/HBRouterMethods","type":"topic"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/ErrorHandling":{"abstract":[{"text":"How to build errors for the server to return.","type":"text"}],"kind":"article","role":"collectionGroup","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/ErrorHandling","url":"\/documentation\/hummingbird\/errorhandling","type":"topic","title":"Error Handling"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/EncodingAndDecoding":{"abstract":[{"text":"Hummingbird uses ","type":"text"},{"code":"Codable","type":"codeVoice"},{"text":" to decode requests and encode responses.","type":"text"}],"title":"Encoding and Decoding","kind":"article","type":"topic","url":"\/documentation\/hummingbird\/encodinganddecoding","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/EncodingAndDecoding","role":"collectionGroup"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/PersistentData":{"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/PersistentData","kind":"article","url":"\/documentation\/hummingbird\/persistentdata","abstract":[{"text":"How to persist data between requests to your server.","type":"text"}],"title":"Persistent data","type":"topic","role":"collectionGroup"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/LoggingMetricsAndTracing":{"abstract":[{"text":"Considered the three pillars of observability, logging, metrics and tracing provide different ways of viewing how your application is working.","type":"text"}],"kind":"article","role":"collectionGroup","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/LoggingMetricsAndTracing","url":"\/documentation\/hummingbird\/loggingmetricsandtracing","type":"topic","title":"Logging, Metrics and Tracing"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/RequestContexts":{"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/RequestContexts","kind":"article","url":"\/documentation\/hummingbird\/requestcontexts","abstract":[{"text":"Controlling contextual data provided to middleware and route handlers","type":"text"}],"title":"Request Contexts","type":"topic","role":"collectionGroup"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/Testing":{"kind":"article","role":"article","abstract":[{"type":"text","text":"Using the HummingbirdXCT framework to test your application"}],"title":"Testing","url":"\/documentation\/hummingbird\/testing","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/Testing","type":"topic"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/MigratingToV2":{"role":"article","title":"Migrating to Hummingbird v2","kind":"article","url":"\/documentation\/hummingbird\/migratingtov2","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/MigratingToV2","type":"topic","abstract":[{"type":"text","text":"Migration guide for converting Hummingbird v1 applications to Hummingbird v2"}]},"doc://com.opticalaberration.hummingbird/documentation/index":{"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/index","kind":"article","url":"\/documentation\/index","abstract":[{"text":"Lightweight, flexible, modern server framework written in Swift.","type":"text"}],"title":"Hummingbird","type":"topic","role":"collection"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/HBRouterGroup":{"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/HBRouterGroup","url":"\/documentation\/hummingbird\/hbroutergroup","navigatorTitle":[{"text":"HBRouterGroup","kind":"identifier"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HBRouterGroup","kind":"identifier"}],"kind":"symbol","abstract":[{"text":"Used to group together routes under a single path. Additional middleware can be added to the endpoint and each route can add a","type":"text"},{"text":" ","type":"text"},{"text":"suffix to the endpoint path","type":"text"}],"role":"symbol","type":"topic","title":"HBRouterGroup"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/HBRouter":{"abstract":[{"text":"Create rules for routing requests and then create ","type":"text"},{"type":"codeVoice","code":"HBResponder"},{"text":" that will follow these rules.","type":"text"}],"url":"\/documentation\/hummingbird\/hbrouter","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/HBRouter","kind":"symbol","role":"symbol","title":"HBRouter","navigatorTitle":[{"text":"HBRouter","kind":"identifier"}],"fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"text":"HBRouter","kind":"identifier"}],"type":"topic"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/ServiceLifecycle":{"identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/ServiceLifecycle","abstract":[{"text":"Integration with Swift Service Lifecycle","type":"text"}],"url":"\/documentation\/hummingbird\/servicelifecycle","type":"topic","title":"Service Lifecycle","kind":"article","role":"article"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/HBRouter/on(_:method:options:use:)-1zuke":{"abstract":[{"type":"text","text":"Add path for closure returning type conforming to HBResponseGenerator"}],"role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"text":"on","kind":"identifier"},{"kind":"text","text":"("},{"text":"String","kind":"typeIdentifier","preciseIdentifier":"s:SS"},{"kind":"text","text":", "},{"kind":"externalParam","text":"method"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"HTTPRequest","preciseIdentifier":"s:9HTTPTypes11HTTPRequestV"},{"kind":"text","text":"."},{"preciseIdentifier":"s:9HTTPTypes11HTTPRequestV6MethodV","text":"Method","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"options"},{"kind":"text","text":": "},{"text":"HBRouterMethodOptions","kind":"typeIdentifier","preciseIdentifier":"s:11Hummingbird21HBRouterMethodOptionsV"},{"text":", ","kind":"text"},{"text":"use","kind":"externalParam"},{"kind":"text","text":": ("},{"kind":"typeIdentifier","preciseIdentifier":"s:15HummingbirdCore9HBRequestV","text":"HBRequest"},{"kind":"text","text":", "},{"text":"Context","preciseIdentifier":"s:11Hummingbird8HBRouterC7Contextxmfp","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"text":"async","kind":"keyword"},{"text":" ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"some","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HBResponseGenerator","preciseIdentifier":"s:11Hummingbird19HBResponseGeneratorP","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"Self","kind":"typeIdentifier"}],"kind":"symbol","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/HBRouter\/on(_:method:options:use:)-1zuke","url":"\/documentation\/hummingbird\/hbrouter\/on(_:method:options:use:)-1zuke","type":"topic","title":"on(_:method:options:use:)"}}}