{"identifier":{"url":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/MustacheSyntax","interfaceLanguage":"swift"},"sections":[],"kind":"article","metadata":{"roleHeading":"Article","role":"article","title":"Mustache Syntax","modules":[{"name":"HummingbirdMustache"}]},"hierarchy":{"paths":[["doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdMustache"]]},"schemaVersion":{"minor":3,"major":0,"patch":0},"abstract":[{"type":"text","text":"Overview of Mustache Syntax"}],"primaryContentSections":[{"kind":"content","content":[{"level":2,"text":"Overview","type":"heading","anchor":"Overview"},{"inlineContent":[{"text":"Mustache is a “logic-less” templating engine. The core language has no flow control statements. Instead it has tags that can be replaced with a value, nothing or a series of values. Below we document all the standard tags","type":"text"}],"type":"paragraph"},{"level":2,"anchor":"Context","type":"heading","text":"Context"},{"inlineContent":[{"text":"Mustache renders a template with a context stack. A context is a list of key\/value pairs. These can be represented by either a ","type":"text"},{"type":"codeVoice","code":"Dictionary"},{"text":" or the reflection information from ","type":"text"},{"type":"codeVoice","code":"Mirror"},{"type":"text","text":". For example the following two objects will render in the same way"}],"type":"paragraph"},{"syntax":"swift","code":["let object = [\"name\": \"John Smith\", \"age\": 68]"],"type":"codeListing"},{"syntax":"swift","code":["struct Person {","    let name: String","    let age: Int","}","let object = Person(name: \"John Smith\", age: 68)"],"type":"codeListing"},{"inlineContent":[{"text":"Initially the stack will consist of the root context object you want to render. When we enter a section tag we push the associated value onto the context stack and when we leave the section we pop that value back off the stack.","type":"text"}],"type":"paragraph"},{"level":2,"anchor":"Tags","type":"heading","text":"Tags"},{"inlineContent":[{"text":"All tags are surrounded by a double curly bracket ","type":"text"},{"type":"codeVoice","code":"{{}}"},{"text":". When a tag has a reference to a key, the key will be searched for from the context at the top of the context stack and the associated value will be output. If the key cannot be found then the next context down will be searched and so on until either a key is found or we have reached the bottom of the stack. If no key is found the output for that value is ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"A tag can be used to reference a child value from the associated value of a key by using dot notation in a similar manner to Swift. eg in ","type":"text"},{"code":"{{main.sub}}","type":"codeVoice"},{"text":" the first context is searched for the  ","type":"text"},{"code":"main","type":"codeVoice"},{"text":" key. If a value is found, that value is used as a context and the key ","type":"text"},{"code":"sub","type":"codeVoice"},{"text":" is used to search within that context and so on.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If you want to only search for values in the context at the top of the stack then prefix the variable name with a “.” eg "},{"type":"codeVoice","code":"{{.key}}"}],"type":"paragraph"},{"level":2,"anchor":"Tag-types","type":"heading","text":"Tag types"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"code":"{{key}}","type":"codeVoice"},{"text":": Render value associated with ","type":"text"},{"code":"key","type":"codeVoice"},{"text":" as text. By default this is HTML escaped. A ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":" value is rendered as an empty string.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"{{{name}}}"},{"type":"text","text":": Acts the same as "},{"type":"codeVoice","code":"{{name}}"},{"type":"text","text":" except the resultant text is not HTML escaped. You can also use "},{"type":"codeVoice","code":"{{&name}}"},{"type":"text","text":" to avoid HTML escaping."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"{{#section}}","type":"codeVoice"},{"text":": Section render blocks either render text once or multiple times depending on the value of the key in the current context. A section begins with ","type":"text"},{"code":"{{#section}}","type":"codeVoice"},{"text":" and end with ","type":"text"},{"code":"{{\/section}}","type":"codeVoice"},{"text":". If the key represents a ","type":"text"},{"code":"Bool","type":"codeVoice"},{"text":" value it will only render if it is true. If the key represents an ","type":"text"},{"code":"Optional","type":"codeVoice"},{"text":" it will only render if the object is non-nil. If the key represents an ","type":"text"},{"code":"Array","type":"codeVoice"},{"text":" it will then render the internals of the section multiple times, once for each element of the ","type":"text"},{"code":"Array","type":"codeVoice"},{"text":". Otherwise it will render with the selected value pushed onto the top of the context stack.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"{{^section}}"},{"type":"text","text":": An inverted section does the opposite of a section. If the key represents a "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" value it will render if it is false. If the key represents an "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":" it will render if it is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". If the key represents a "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" it will render if the "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" is empty."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"{{! comment }}","type":"codeVoice"},{"type":"text","text":": This is a comment tag and is ignored."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"{{> partial}}"},{"type":"text","text":": A partial tag renders another mustache file, with the current context stack. In Hummingbird Mustache partial tags only work for templates that are a part of a library and the tag is the name of the referenced file without the “.mustache” extension."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"{{=<% %>=}}","type":"codeVoice"},{"text":": The set delimiter tag allows you to change from using the double curly brackets as tag delimiters. In the example the delimiters have been changed to ","type":"text"},{"code":"<% %>","type":"codeVoice"},{"text":" but you can change them to whatever you like.","type":"text"}]}]}]},{"inlineContent":[{"type":"text","text":"You can find out more about the standard Mustache tags in the "},{"identifier":"https:\/\/mustache.github.io\/mustache.5.html","type":"reference","isActive":true},{"type":"text","text":"."}],"type":"paragraph"}]}],"references":{"https://mustache.github.io/mustache.5.html":{"identifier":"https:\/\/mustache.github.io\/mustache.5.html","url":"https:\/\/mustache.github.io\/mustache.5.html","type":"link","title":"Mustache Manual","titleInlineContent":[{"text":"Mustache Manual","type":"text"}]},"doc://com.opticalaberration.hummingbird/documentation/HummingbirdMustache":{"type":"topic","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdMustache","title":"HummingbirdMustache","role":"collection","url":"\/documentation\/hummingbirdmustache","abstract":[{"text":"Mustache template engine.","type":"text"}],"kind":"symbol"}}}