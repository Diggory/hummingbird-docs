{"topicSections":[{"identifiers":["doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdLambda\/HBRouterBuilder","doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdLambda\/HBRouterGroup","doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdLambda\/HBRouterMethods"],"title":"Reference"}],"sections":[],"abstract":[{"text":"The router directs requests to their handlers based on the contents of their path.","type":"text"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/Router"},"kind":"article","schemaVersion":{"major":0,"patch":0,"minor":3},"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","text":"Overview","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"The router that comes with Hummingbird uses a Trie based lookup. Routes are added using the function "},{"type":"codeVoice","code":"on"},{"type":"text","text":". You provide the URI path, the method and the handler function. Below is a simple route which returns “Hello” in the body of the response."}]},{"syntax":"swift","type":"codeListing","code":["let app = HBApplication()","app.router.on(\"\/hello\", method: .GET) { request in","    return \"Hello\"","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you don’t provide a path then the default is for it to be “\/”."}]},{"anchor":"Methods","text":"Methods","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are shortcut functions for common HTTP methods. The above can be written as"}]},{"syntax":"swift","type":"codeListing","code":["let app = HBApplication()","app.router.get(\"\/hello\") { request in","    return \"Hello\"","}"]},{"type":"paragraph","inlineContent":[{"text":"There are shortcuts for ","type":"text"},{"type":"codeVoice","code":"put"},{"text":", ","type":"text"},{"type":"codeVoice","code":"post"},{"text":", ","type":"text"},{"type":"codeVoice","code":"head"},{"text":", ","type":"text"},{"type":"codeVoice","code":"patch"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"delete"},{"text":" as well.","type":"text"}]},{"anchor":"Response-generators","text":"Response generators","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Route handlers are required to return either a type conforming to the "},{"code":"HBResponseGenerator","type":"codeVoice"},{"type":"text","text":" protocol or an "},{"code":"EventLoopFuture","type":"codeVoice"},{"type":"text","text":" of a type conforming to "},{"code":"HBResponseGenerator","type":"codeVoice"},{"type":"text","text":". An "},{"code":"EventLoopFuture","type":"codeVoice"},{"type":"text","text":" is an object that will fulfilled with their value at a later date in an asynchronous manner. The "},{"code":"HBResponseGenerator","type":"codeVoice"},{"type":"text","text":" protocol requires an object to be able to generate an "},{"code":"HBResponse","type":"codeVoice"},{"type":"text","text":". For example "},{"code":"String","type":"codeVoice"},{"type":"text","text":" has been extended to conform to "},{"code":"HBResponseGenerator","type":"codeVoice"},{"type":"text","text":" by returning an "},{"code":"HBResponse","type":"codeVoice"},{"type":"text","text":" with status "},{"code":".ok","type":"codeVoice"},{"type":"text","text":",  a content-type header of "},{"code":"text-plain","type":"codeVoice"},{"type":"text","text":" and a body holding the contents of the "},{"code":"String","type":"codeVoice"},{"type":"text","text":"."}]},{"syntax":"swift","type":"codeListing","code":["\/\/\/ Extend String to conform to ResponseGenerator","extension String: HBResponseGenerator {","    \/\/\/ Generate response holding string","    public func response(from request: HBRequest) -> HBResponse {","        let buffer = request.allocator.buffer(string: self)","        return HBResponse(status: .ok, headers: [\"content-type\": \"text\/plain; charset=utf-8\"], body: .byteBuffer(buffer))","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"In addition to ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":", ","type":"text"},{"code":"HTTPResponseStatus","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Optional","type":"codeVoice"},{"text":" have also been extended to conform to ","type":"text"},{"code":"HBResponseGenerator","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It is also possible to extend "},{"type":"codeVoice","code":"Codable"},{"type":"text","text":" objects to generate "},{"type":"codeVoice","code":"HBResponses"},{"type":"text","text":" by conforming these objects to "},{"type":"codeVoice","code":"HBResponseEncodable"},{"type":"text","text":". The object will use "},{"type":"codeVoice","code":"HBApplication.encoder"},{"type":"text","text":" to encode these objects. If an object conforms to "},{"type":"codeVoice","code":"HBResponseEncodable"},{"type":"text","text":" then also so do arrays of these objects and dictionaries."}]},{"anchor":"Wildcards","text":"Wildcards","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"You can use wildcards to match sections of a path component.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"A single ","type":"text"},{"code":"*","type":"codeVoice"},{"text":" will skip one path component","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["app.router.get(\"\/files\/*\") { request in","    return request.uri.description","}"]},{"type":"paragraph","inlineContent":[{"text":"Will match","type":"text"}]},{"syntax":null,"type":"codeListing","code":["GET \/files\/test","GET \/files\/test2"]},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"code":"*","type":"codeVoice"},{"text":" at the start of a route component will match all path components with the same suffix.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["app.router.get(\"\/files\/*.jpg\") { request in","    return request.uri.description","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Will work for"}]},{"syntax":null,"type":"codeListing","code":["GET \/files\/test.jpg","GET \/files\/test2.jpg"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"*"},{"type":"text","text":" at the end of a route component will match all path components with the same prefix."}]},{"syntax":"swift","type":"codeListing","code":["app.router.get(\"\/files\/image.*\") { request in","    return request.uri.description","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Will work for"}]},{"syntax":null,"type":"codeListing","code":["GET \/files\/image.jpg","GET \/files\/image.png"]},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"type":"codeVoice","code":"**"},{"text":" will match and capture all remaining path components.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["app.router.get(\"\/files\/**\") { request in","    \/\/ return catchAll captured string","    return request.parameters.getCatchAll().joined(separator: \"\/\")","}"]},{"type":"paragraph","inlineContent":[{"text":"The above will match routes and respond as follows","type":"text"}]},{"syntax":null,"type":"codeListing","code":["GET \/files\/image.jpg returns \"image.jpg\" in the response body","GET \/files\/folder\/image.png returns \"folder\/image.png\" in the response body"]},{"anchor":"Parameter-Capture","text":"Parameter Capture","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can extract parameters out of the URI by prefixing the path with a colon. This indicates that this path section is a parameter. The parameter name is the string following the colon. You can get access to the parameters extracted from the URI with "},{"type":"codeVoice","code":"HBRequest.parameters"},{"type":"text","text":". If there are no URI parameters in the path, accessing "},{"type":"codeVoice","code":"HBRequest.parameters"},{"type":"text","text":" will cause a crash, so don’t use it if you haven’t specified a parameter in the route path. This example extracts an id from the URI and uses it to return a specific user. so “\/user\/56” will return user with id 56."}]},{"syntax":"swift","type":"codeListing","code":["app.router.get(\"\/user\/:id\") { request in","    let id = request.parameters.get(\"id\", as: Int.self) else { throw HBHTTPError(.badRequest) }","    return getUser(id: id)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above if I fail to access the parameter as an "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" then I throw an error. If you throw an "},{"type":"codeVoice","code":"HBHTTPError"},{"type":"text","text":" it will get converted to a valid HTTP response."}]},{"type":"paragraph","inlineContent":[{"text":"The parameter name in your route can also be of the form ","type":"text"},{"code":"${id}","type":"codeVoice"},{"text":". With this form you can also extract parameter values from the URI that are prefixes or suffixes of a path component.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["app.router.get(\"\/files\/${image}.jpg\") { request in","    let imageName = request.parameters.get(\"image\") else { throw HBHTTPError(.badRequest) }","    return getImage(image: imageName)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above we match all pathes that are a file with a jpg extension inside the files folder and then call a function with that image name."}]},{"anchor":"Groups","text":"Groups","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Routes can be grouped together in a "},{"type":"codeVoice","code":"HBRouterGroup"},{"type":"text","text":".  These allow for you to prefix a series of routes with the same path and more importantly apply middleware to only those routes. The example below is a group that includes five handlers all prefixed with the path “\/todos”."}]},{"syntax":"swift","type":"codeListing","code":["let app = HBApplication()","app.router.group(\"\/todos\")","    .put(use: createTodo)","    .get(use: listTodos)","    .get(\":id\", getTodo)","    .patch(\":id\", editTodo)","    .delete(\":id\", deleteTodo)"]},{"anchor":"Route-handlers","text":"Route handlers","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"A route handler "},{"type":"codeVoice","code":"HBRouteHandler"},{"type":"text","text":" allows you to encapsulate all the components required for a route, and provide separation of the extraction of input parameters from the request and the processing of those parameters. An example could be structrured as follows"}]},{"syntax":"swift","type":"codeListing","code":["struct AddOrder: HBRouteHandler {","    struct Input: Decodable {","        let name: String","        let amount: Double","    }","    struct Output: HBResponseEncodable {","        let id: String","    }","    let input: Input","    let user: User","    ","    init(from request: HBRequest) throws {","        self.input = try request.decode(as: Input.self)","        self.user = try request.auth.require(User.self)","    }","    func handle(request: HBRequest) -> EventLoopFuture<Output> {","        let order = Order(user: self.user.id, details: self.input)","        return order.save(on: request.db)","            .map { .init(id: order.id) }","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"Here you can see the ","type":"text"},{"type":"codeVoice","code":"AddOrder"},{"text":" route handler encapsulates everything you need to know about the add order route. The ","type":"text"},{"type":"codeVoice","code":"Input"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Output"},{"text":" structs are defined and any additional input parameters that need extracted from the ","type":"text"},{"type":"codeVoice","code":"HBRequest"},{"text":". The input parameters are extracted in the ","type":"text"},{"type":"codeVoice","code":"init"},{"text":" and then the request is processed in the ","type":"text"},{"type":"codeVoice","code":"handle"},{"text":" function. In this example we need to decode the ","type":"text"},{"type":"codeVoice","code":"Input"},{"text":" from the ","type":"text"},{"type":"codeVoice","code":"HBRequest"},{"text":" and using the authentication framework from ","type":"text"},{"type":"codeVoice","code":"HummingbirdAuth"},{"text":" we get the authenticated user.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following will add the handler to the application"}]},{"syntax":"swift","type":"codeListing","code":["application.router.put(\"order\", use: AddOrder.self)"]},{"anchor":"Streaming-request-body","text":"Streaming request body","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"By default Hummingbird will collate the contents of your request body into one ByteBuffer. You can access this via "},{"code":"HBRequest.body.buffer","type":"codeVoice"},{"type":"text","text":". If you’d prefer to stream the content of the request body, you can add a "},{"code":".streamBody","type":"codeVoice"},{"type":"text","text":" option to the route handler to receive a streaming body instead of a single "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":". Inside the route handler you access this stream via "},{"code":"HBRequest.body.stream","type":"codeVoice"},{"type":"text","text":". The request body parts are then accessed either via "},{"code":"consume","type":"codeVoice"},{"type":"text","text":" function which will return everything that has been streamed so far or a "},{"code":"consumeAll","type":"codeVoice"},{"type":"text","text":" function which takes a closure processing each part. Here is an example which reads the request buffer and returns it size"}]},{"syntax":"swift","type":"codeListing","code":["application.router.post(\"size\", options: .streamBody) { request -> EventLoopFuture<String> in","    guard let stream = request.body.stream else { ","        return request.failure(.badRequest)","    }","    var size = 0","    return stream.consumeAll(on: request.eventLoop) { buffer in","        size += buffer.readableBytes","        return request.eventLoop.makeSucceededFuture(())","    }","    .map { size.description }","}"]},{"anchor":"Editing-response-in-handler","text":"Editing response in handler","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"The standard way to provide a custom response from a route handler is to return a ","type":"text"},{"type":"codeVoice","code":"HBResponse"},{"text":" from that handler. This method loses a lot of the automation of encoding responses, generating the correct status code etc.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There is another method though that allows you to edit a response even when returning something other than a "},{"type":"codeVoice","code":"HBResponse"},{"type":"text","text":". First you need to flag your route to say it is editing the response using the option "},{"type":"codeVoice","code":".editResponse"},{"type":"text","text":". Once you have set this option you can edit your response via "},{"type":"codeVoice","code":"HBRequest.response"},{"type":"text","text":". This allows you to add new headers, replace generated headers or set the status code. Below is a route replacing the generated "},{"type":"codeVoice","code":"content-type"},{"type":"text","text":" header and setting the status code."}]},{"syntax":"swift","type":"codeListing","code":["application.router.post(\"test\", options: .editResponse) { request -> String in","    request.response.headers.replaceOrAdd(name: \"content-type\", value: \"application\/json\")","    request.response.status = .accepted","    return #\"{\"test\": \"value\"}\"#","}"]}]}],"hierarchy":{"paths":[["doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird"],["doc:\/\/com.opticalaberration.hummingbird\/documentation\/index"]]},"metadata":{"role":"collectionGroup","title":"Router","modules":[{"name":"Hummingbird"}]},"seeAlsoSections":[{"identifiers":["doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/EncodingAndDecoding","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/ErrorHandling","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/ExtendingHummingbird","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/LoggingMetricsAndTracing","doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/PersistentData"],"title":"Articles","generated":true}],"references":{"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/ErrorHandling":{"title":"Error Handling","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/ErrorHandling","type":"topic","abstract":[{"type":"text","text":"How to build errors for the server to return."}],"url":"\/documentation\/hummingbird\/errorhandling","kind":"article","role":"article"},"doc://com.opticalaberration.hummingbird/documentation/HummingbirdLambda/HBRouterGroup":{"title":"HBRouterGroup","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"HBRouterGroup"}],"kind":"symbol","abstract":[{"text":"Used to group together routes under a single path. Additional middleware can be added to the endpoint and each route can add a","type":"text"},{"text":" ","type":"text"},{"text":"suffix to the endpoint path","type":"text"}],"role":"symbol","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdLambda\/HBRouterGroup","type":"topic","url":"\/documentation\/hummingbirdlambda\/hbroutergroup","navigatorTitle":[{"kind":"identifier","text":"HBRouterGroup"}]},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/PersistentData":{"abstract":[{"text":"How to persist data between requests to your server.","type":"text"}],"type":"topic","kind":"article","url":"\/documentation\/hummingbird\/persistentdata","role":"collectionGroup","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/PersistentData","title":"Persistent data"},"doc://com.opticalaberration.hummingbird/documentation/index":{"url":"\/documentation\/index","role":"collection","abstract":[{"text":"Lightweight, flexible server framework written in Swift.","type":"text"}],"title":"Hummingbird","kind":"article","type":"topic","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/index"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/ExtendingHummingbird":{"abstract":[{"type":"text","text":"How to extend core types of Hummingbird"}],"type":"topic","kind":"article","url":"\/documentation\/hummingbird\/extendinghummingbird","role":"article","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/ExtendingHummingbird","title":"Extending Hummingbird"},"doc://com.opticalaberration.hummingbird/documentation/HummingbirdLambda/HBRouterMethods":{"url":"\/documentation\/hummingbirdlambda\/hbroutermethods","navigatorTitle":[{"text":"HBRouterMethods","kind":"identifier"}],"role":"symbol","abstract":[{"text":"Conform to ","type":"text"},{"code":"HBRouterMethods","type":"codeVoice"},{"text":" to add standard router verb (get, post …) methods","type":"text"}],"title":"HBRouterMethods","kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HBRouterMethods","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdLambda\/HBRouterMethods"},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/LoggingMetricsAndTracing":{"kind":"article","title":"Logging, Metrics and Tracing","url":"\/documentation\/hummingbird\/loggingmetricsandtracing","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/LoggingMetricsAndTracing","type":"topic","role":"collectionGroup","abstract":[{"text":"Considered the three pillars of observability, logging, metrics and tracing provide different ways of viewing how your application is working.","type":"text"}]},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird":{"title":"Hummingbird","role":"collection","kind":"symbol","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird","url":"\/documentation\/hummingbird","type":"topic","abstract":[{"text":"Lightweight, flexible server framework written in Swift.","type":"text"}]},"doc://com.opticalaberration.hummingbird/documentation/Hummingbird/EncodingAndDecoding":{"title":"Encoding and Decoding","kind":"article","abstract":[{"type":"text","text":"Hummingbird uses "},{"type":"codeVoice","code":"Codable"},{"type":"text","text":" to decode requests and encode responses."}],"role":"collectionGroup","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/Hummingbird\/EncodingAndDecoding","type":"topic","url":"\/documentation\/hummingbird\/encodinganddecoding"},"doc://com.opticalaberration.hummingbird/documentation/HummingbirdLambda/HBRouterBuilder":{"title":"HBRouterBuilder","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"HBRouterBuilder"}],"kind":"symbol","abstract":[{"type":"text","text":"Create rules for routing requests and then create "},{"type":"codeVoice","code":"HBResponder"},{"type":"text","text":" that will follow these rules."}],"role":"symbol","identifier":"doc:\/\/com.opticalaberration.hummingbird\/documentation\/HummingbirdLambda\/HBRouterBuilder","type":"topic","url":"\/documentation\/hummingbirdlambda\/hbrouterbuilder","navigatorTitle":[{"kind":"identifier","text":"HBRouterBuilder"}]}}}